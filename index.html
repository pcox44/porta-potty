<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Porta Potty Problem Simulator</title>
<style>
body {
  font-family: 'Segoe UI', sans-serif;
  background: linear-gradient(135deg, #1a1a1a, #2b2b2b);
  color: #fff;
  text-align: center;
  padding: 20px;
}
h1 { margin-bottom: 10px; color: #ffce00; }
p.description { margin: 0 0 20px; font-size: 1em; color: #ddd; }
.controls { margin: 20px 0; }
input[type=range] { width: 200px; }
button { margin: 5px; padding: 8px 15px; font-weight: bold; cursor: pointer; border-radius: 5px; border: none; background: #ffce00; color: #000; }
button:hover { background: #ffc107; }
#applicants {
  display: grid;
  grid-template-columns: repeat(10, 40px);
  justify-content: center;
  gap: 6px;
  margin-top: 20px;
}
.applicant {
  width: 35px; height: 35px;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 0.8em;
  font-weight: bold;
  color: #fff;
  background: gray;
  position: relative;
  transition: transform 0.3s, box-shadow 0.3s, background 0.3s;
  cursor: default;
}
.applicant.selected { box-shadow: 0 0 10px 3px #ff0000; transform: scale(1.3); animation: pulse 0.6s infinite alternate; }
.applicant.skip { background: rgba(255,255,0,0.5); color: #000; }
.applicant.best { background: green; color: #fff; }
.applicant:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  top: -25px;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.7em;
  white-space: nowrap;
  pointer-events: none;
}
@keyframes pulse {
  0% { transform: scale(1.3); box-shadow: 0 0 10px 3px #ff0000; }
  100% { transform: scale(1.5); box-shadow: 0 0 20px 6px #ff0000; }
}
#stats { margin-top: 20px; font-size: 1.1em; }
#graph {
  margin-top: 20px;
  height: 300px;
  width: 90%;
  max-width: 900px;
  background: linear-gradient(to top, #111, #222);
  position: relative;
  margin-left: auto;
  margin-right: auto;
  border: 1px solid #fff;
  padding-left: 40px; /* space for y-axis labels */
  padding-bottom: 30px; /* space for x-axis labels */
}
.line { position: absolute; height: 2px; background: #ffce00; transform-origin: left center; }
.labelPoint { position: absolute; color: #ffce00; font-size: 0.7em; transform: translate(-50%, -100%); }
.axisLabel { position: absolute; color: #fff; font-size: 0.8em; font-weight: bold; }
.tick { position: absolute; background: #fff; }
</style>
</head>
<body>

<h1>Porta Potty Problem Simulator</h1>
<p class="description">A line of porta potties awaits! Each potty has a cleanliness ranking (1 = cleanest). You must pick one as you walk by, but you cannot return once skipped. Try different strategies and see how the 1/e rule performs.</p>

<div class="controls">
  <label>Number of potties: <span id="numLabel">50</span></label><br>
  <input type="range" id="numApplicants" min="10" max="100" value="50"><br>

  <label>Stop after fraction: <span id="stopLabel">0.37</span></label><br>
  <input type="range" id="stopFraction" min="0.05" max="0.95" step="0.01" value="0.37"><br>

  <label><input type="checkbox" id="setE"> Set stop fraction to 1/e</label><br>

  <button onclick="runSimulation()">Run 1 Trial</button>
  <button onclick="runMultiple(100)">Run 100 Trials</button>
  <button onclick="runMultipleAnimated(100)">Animate 100 Trials</button>
  <button onclick="resetGraph()">Reset</button>
</div>

<div id="applicants"></div>
<div id="stats"></div>
<div id="graph"></div>

<script>
const applicantsDiv = document.getElementById('applicants');
const numApplicantsInput = document.getElementById('numApplicants');
const stopFractionInput = document.getElementById('stopFraction');
const numLabel = document.getElementById('numLabel');
const stopLabel = document.getElementById('stopLabel');
const statsDiv = document.getElementById('stats');
const graphDiv = document.getElementById('graph');
const setECheckbox = document.getElementById('setE');

numApplicantsInput.oninput = () => numLabel.textContent = numApplicantsInput.value;
stopFractionInput.oninput = () => { stopLabel.textContent = stopFractionInput.value; setECheckbox.checked=false; };
setECheckbox.onchange = () => { if(setECheckbox.checked){ stopFractionInput.value = (1/Math.E).toFixed(2); stopLabel.textContent = stopFractionInput.value; } };

let averageRanks = [];

function createApplicants(n){
  const arr = Array.from({length:n}, (_,i)=>i+1);
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}

function displayApplicants(arr, selectedIndex=-1, stopIndex=0){
  applicantsDiv.innerHTML='';
  arr.forEach((rank,i)=>{
    const div = document.createElement('div');
    div.className='applicant';
    div.textContent=rank;
    div.dataset.tooltip=`Rank: ${rank}, Position: ${i+1}`;
    if(i<stopIndex) div.classList.add('skip');
    if(i===selectedIndex) {
      div.classList.add('selected');
      if(rank===1) div.classList.add('best');
    }
    applicantsDiv.appendChild(div);
  });
}

function runSingleTrial(n, stopFrac){
  const applicants=createApplicants(n);
  const stop=Math.floor(n*stopFrac);
  let bestSeen=n+1;
  let selectedIndex=-1;
  for(let i=0;i<n;i++){
    if(i<stop) bestSeen=Math.min(bestSeen, applicants[i]);
    else if(applicants[i]<bestSeen){selectedIndex=i;break;}
  }
  if(selectedIndex===-1) selectedIndex=n-1;
  displayApplicants(applicants, selectedIndex, stop);
  const selectedRank=applicants[selectedIndex];
  const success = selectedRank===1?1:0;
  return {selectedRank, success};
}

function runSimulation(){
  const n=parseInt(numApplicantsInput.value);
  const stopFrac=parseFloat(stopFractionInput.value);
  const result=runSingleTrial(n, stopFrac);
  averageRanks.push(result.selectedRank);
  updateStats();
  updateGraph();
}

function runMultiple(trials){
  const n=parseInt(numApplicantsInput.value);
  const stopFrac=parseFloat(stopFractionInput.value);
  let cumulative=averageRanks.length > 0 ? averageRanks[averageRanks.length-1]*averageRanks.length : 0;
  let successes=0;
  let top5=0;
  for(let i=0;i<trials;i++){
    const res=runSingleTrial(n, stopFrac);
    cumulative+=res.selectedRank;
    averageRanks.push(cumulative/(averageRanks.length));
    successes+=res.success;
    if(res.selectedRank<=5) top5++;
  }
  updateStats(successes, top5, trials);
  updateGraph();
}

async function runMultipleAnimated(trials){
  const n=parseInt(numApplicantsInput.value);
  const stopFrac=parseFloat(stopFractionInput.value);
  let cumulative=averageRanks.length > 0 ? averageRanks[averageRanks.length-1]*averageRanks.length : 0;
  let successes=0;
  let top5=0;
  for(let i=0;i<trials;i++){
    const res=runSingleTrial(n, stopFrac);
    cumulative+=res.selectedRank;
    averageRanks.push(cumulative/(averageRanks.length));
    successes+=res.success;
    if(res.selectedRank<=5) top5++;
    updateStats(successes, top5, i+1);
    updateGraph();
    await new Promise(r=>setTimeout(r,20));
  }
}

function updateStats(successes=0, top5=0, trials=1){
  const last = averageRanks[averageRanks.length-1] || 0;
  statsDiv.innerHTML=`
    Average selected rank: ${last.toFixed(2)}<br>
    Success rate (cleanest selected): ${successes}/${trials} (${(successes/trials*100).toFixed(2)}%)<br>
    Top 5 clean selections: ${top5}/${trials}<br>
    Stop fraction: ${stopFractionInput.value} 
  `;
}

function updateGraph(){
  graphDiv.innerHTML='';
  const w=graphDiv.clientWidth-40; // leave space for y-axis labels
  const h=graphDiv.clientHeight-30; // leave space for x-axis labels
  const maxRank=Math.max(...averageRanks,1);

  // draw Y axis ticks and labels
  const yTicks = 5;
  for(let i=0;i<=yTicks;i++){
    const yVal = maxRank*i/yTicks;
    const yPos = h - (yVal/maxRank)*h;
    const tick = document.createElement('div');
    tick.className='tick';
    tick.style.width='5px';
    tick.style.height='1px';
    tick.style.left='35px';
    tick.style.top=yPos+'px';
    graphDiv.appendChild(tick);

    const label = document.createElement('div');
    label.className='axisLabel';
    label.style.left='0px';
    label.style.top=(yPos-7)+'px';
    label.innerText=yVal.toFixed(1);
    graphDiv.appendChild(label);
  }

  // draw X axis ticks and labels
  const xTicks = Math.min(10, averageRanks.length);
  for(let i=0;i<=xTicks;i++){
    const xPos = (i/xTicks)*w+40;
    const label = document.createElement('div');
    label.className='axisLabel';
    label.style.left=xPos+'px';
    label.style.bottom='0px';
    label.style.transform='translateX(-50%)';
    const trialNum = Math.round(i/xTicks*(averageRanks.length-1)+1);
    label.innerText = trialNum;
    graphDiv.appendChild(label);
  }

  // plot the line
  for(let i=1;i<averageRanks.length;i++){
    const x1=((i-1)/(averageRanks.length-1))*w+40;
    const y1=h-(averageRanks[i-1]/maxRank)*h;
    const x2=(i/(averageRanks.length-1))*w+40;
    const y2=h-(averageRanks[i]/maxRank)*h;
    const dx=x2-x1, dy=y2-y1;
    const length=Math.sqrt(dx*dx+dy*dy);
    const angle=Math.atan2(dy,dx)*180/Math.PI;
    const line=document.createElement('div');
    line.className='line';
    line.style.width=length+'px';
    line.style.left=x1+'px';
    line.style.top=y1+'px';
    line.style.transform=`rotate(${angle}deg)`;
    graphDiv.appendChild(line);
  }
}

function resetGraph(){
  graphDiv.innerHTML='';
  statsDiv.innerHTML='';
  averageRanks=[];
  applicantsDiv.innerHTML='';
}
</script>

</body>
</html>
